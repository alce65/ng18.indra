# Angular 17-18

- [Angular 17-18](#angular-17-18)
  - [**PARTE 2. Elementos básicos. Routing, componentes y pipes. Librerías. Testing**](#parte-2-elementos-básicos-routing-componentes-y-pipes-librerías-testing)
    - [Páginas y Routing: lazy loading en las rutas](#páginas-y-routing-lazy-loading-en-las-rutas)
      - [Creación de componentes pages: Home y About](#creación-de-componentes-pages-home-y-about)
      - [Rutas](#rutas)
      - [Rutas lazy](#rutas-lazy)
      - [Menu: navegación sin recarga para una SPA](#menu-navegación-sin-recarga-para-una-spa)
    - [Componentes: estado y binding. Eventos. Templates y control flow. Estilos](#componentes-estado-y-binding-eventos-templates-y-control-flow-estilos)
      - [Opciones del menu como propiedad: uso de @for](#opciones-del-menu-como-propiedad-uso-de-for)
        - [Opciones del menu leídas desde las rutas](#opciones-del-menu-leídas-desde-las-rutas)
      - [Componente Contador (Counter): estado y eventos](#componente-contador-counter-estado-y-eventos)
      - [Uso condicional de clases CSS](#uso-condicional-de-clases-css)
      - [Limites en el contador: renderizado condicional](#limites-en-el-contador-renderizado-condicional)
      - [Componente saludo: two-way data binding with ngModel](#componente-saludo-two-way-data-binding-with-ngmodel)
      - [Los estilos y los componentes](#los-estilos-y-los-componentes)
    - [Challenge 1](#challenge-1)
      - [Solución de Challenge 1](#solución-de-challenge-1)
    - [Librerías, más componentes. Proyección de componentes](#librerías-más-componentes-proyección-de-componentes)
      - [Creación de una librería](#creación-de-una-librería)
      - [Componentes Header y Footer en la librería](#componentes-header-y-footer-en-la-librería)
      - [Componente Layout: proyección de componentes](#componente-layout-proyección-de-componentes)
      - [Componente Logo](#componente-logo)
      - [Proyección de más de un contenido](#proyección-de-más-de-un-contenido)
    - [Pipes](#pipes)
      - [Valores "localizados": Locale](#valores-localizados-locale)
    - [_Testing de los componentes_](#testing-de-los-componentes)
      - [_Test de la aplicación_](#test-de-la-aplicación)
      - [_Tests de la librería_](#tests-de-la-librería)
      - [_Test del componente Message_](#test-del-componente-message)
      - [_Test del componente Menu_](#test-del-componente-menu)
      - [_Test del componente Counter_](#test-del-componente-counter)
      - [_Test del componente Greeting_](#test-del-componente-greeting)
    - [Challenge 2. Construyendo componentes](#challenge-2-construyendo-componentes)
      - [Redistribuyendo un componente](#redistribuyendo-un-componente)
        - [Solución: Componentización del ejemplo que viene con Angular](#solución-componentización-del-ejemplo-que-viene-con-angular)
      - [Página TODO. Componente 'TODO List' unitario](#página-todo-componente-todo-list-unitario)
        - [Solución del Challenge 2: ToDo List](#solución-del-challenge-2-todo-list)
        - [La vista (template)](#la-vista-template)
        - [La lógica del componente](#la-lógica-del-componente)
        - [_Los tests_](#los-tests)
    - [Scripts npm y Terminales](#scripts-npm-y-terminales)


## **PARTE 2. Elementos básicos. Routing, componentes y pipes. Librerías. Testing**

En esta segunda parte veremos

- el **enrutamiento** entre componentes a los que vamos a denominar página
- la **carga diferida** (lazy loading) de esas **páginas** (componentes standalone)
- las principales funcionalidades de los **componentes**
  - la clase ES y su template
  - el estado y el binding con el template
  - los eventos
  - los nuevos elementos de 'control flow' de Angular 17
  - los estilos CSS
- la creación de proyectos de tipo **librería**
- la **proyección de contenidos** el los componentes
- los **pipes**

Finalmente comenzaremos el tema del **testing** completando los tests de todos los componentes creados hasta ahora

### Páginas y Routing: lazy loading en las rutas

#### Creación de componentes pages: Home y About

Para disponer de enrutamiento vamos a crear las páginas **_Home_** y **_About_**

NO existen como tal las páginas
Podemos llamar así a los componentes invocados directamente en las rutas y usarlos como contenedores
podemos crearlos con el modo inline para el template (-t) y para los estilos  (-s)

```shell
ng g c pages/home -t -s
ng g c pages/about -t -s
```

Igualmente podemos eliminar el selector (--skip-selector),
ya que la página será accedida como ruta y en ningún caso consumida desde otro template

```shell
ng g c pages/home -t -s --skip-selector
ng g c pages/about  -t -s --skip-selector
```

Modificamos nuestro componente para incluir propiedades y su interpolación en el template

```ts

@Component({
  // selector: 'isdi-home',
  standalone: true,
  imports: [],
  template: `<h2>{{ title }}</h2>`,
  styles: ``,
})
export default class HomeComponent {
  title = 'Home page'
}
```

#### Rutas

En el fichero de rutas, añadimos las páginas incluyendo las re-direcciones para la url vacía o cualquier error

```ts
  export const routes: Routes = [
    { path: '', pathMatch: 'full', redirectTo: 'home' },
    { path: 'home', title: 'Home', component: HomeComponent },
    { path: 'about', title: 'Acerca de', component: AboutComponent },
    { path: '**', redirectTo: 'home' },
  ];
```

Comprobamos su funcionamiento escribiendo directamente las rutas en el navegador

El componente sample lo reubicamos en la página about
Vemos que para usar un componente es necesario **importarlo en los metadata** del otro

#### Rutas lazy

Cambiamos las rutas para que carguen la páginas de forma lazy o diferida:
en el momento en el que son requeridas por primera vez

Para ello angular usa los import dinámicos soportados por el actual estándar de ES

El objeto Route disponía de la propiedad loadChildren, para referirse a los módulos en carga lazy;
en las últimas versiones se añade la propiedad **loadComponent**, con la misma funcionalidad para los componentes

Nos aseguramos de no importar los componentes de forma estática

```ts
  { path: '', pathMatch: 'full', redirectTo: 'home' },
  {
    path: 'home',
    title: 'Home',
    loadComponent: () =>
      import('./pages/home/home.component').then((c) => c.HomeComponent),
  },

  {
    path: 'about',
    title: 'Acerca de',
    loadComponent: () =>
      import('./pages/about/about.component').then((c) => c.AboutComponent),
  },
  { path: '**', redirectTo: 'home' },
```

Si los componentes usados como páginas **exportan** la clase como **default**,
no es necesario el método then para indicar el nombre del componente

```ts
  { path: '', pathMatch: 'full', redirectTo: 'home' },
  {
    path: 'home',
    title: 'Home',
    loadComponent: () =>
      import('./pages/home/home.component'),
  },

  {
    path: 'about',
    title: 'Acerca de',
    loadComponent: () =>
      import('./pages/about/about.component'),
  },
  { path: '**', redirectTo: 'home' },
```

#### Menu: navegación sin recarga para una SPA

Creamos un componente menu

```shell
ng g c components/menu
```

Lo incorporamos en app.component, antes del router outlet

Para poder usar directivas de routing es necesario que el componente importe de Angular
el módulo responsable de esta funcionalidad, RoutingModule

```ts
@Component({
  selector: 'isdi-menu',
  standalone: true,
  imports: [RouterModule],
  templateUrl: './menu.component.html',
  styleUrl: './menu.component.scss',
})
export class MenuComponent {}
```

De esa forma, el template puede definir el comportamiento de los hiperenlaces como una navegación SPA

```html
<a [routerLink]="'home'" routerLinkActive="link-active">Home</a>
```

Si incluimos la clase CSS en los estilos, se aplicara automáticamente en el elemento del menu que esté activo

```scss
  nav {
    ul {
      list-style: none;
      display: flex;
      li {
        display: block;
        padding: 0.2rem 0.5rem;
        a {
          text-decoration: none;
          color: inherit;
        }
      }
    }
  }

  .link-active {
    font-weight: 500;
    font-size: 1.1rem;
    position: relative;
    top: -2px;
    transition: font-weight 2s;
    border-bottom: 1px solid;
  }
```

### Componentes: estado y binding. Eventos. Templates y control flow. Estilos

#### Opciones del menu como propiedad: uso de @for

Creamos un interface con el CLI

```shell
  ng g i interfaces/menu.option
```

Definimos en el el objeto que representa una ruta (path y label)

```ts
  export interface MenuOption {
    path: string;
    label: string;
  }
```

Añadimos en el componente menu una propiedad con el array de opciones del menu

```ts
  options: MenuOption[] = [
    { path: 'home', label: 'Home' },
    { path: 'about', label: 'Acerca de' },
  ];
```

En el template iteramos sobre esa propiedad para construir el menu

```html
 @for (option of options; track $index) {
  <li><a [routerLink]="option.path" routerLinkActive="link-active">{{option.label}}</a></li>
  }
```

Estamos usando una de las nuevas flow controls, que sustituyen a las directivas estructurales en Angular 17

Al mismo tiempo vemos las dos formas de incorporar expresiones de ES en los templates de Angular

- como atributos de los componentes: []
- como interpolaciones en el contenido: {{}}

##### Opciones del menu leídas desde las rutas

En lugar de definir las opciones del menu en el componente app, podemos leerlas directamente de las rutas, creando para ello una función en el archivo de rutas

```ts
  const createMenuOptions = (routes) =>  routes
    .filter(
      (route) =>
        !route.path?.includes(':') &&
        !route.path?.includes('*') &&
        route.path !== '',
    )
    .map((route) => ({ path: route.path, label: route.title }) as MenuOption);
```

Generamos las opciones del menu en el componente app leyéndolas de las rutas

```ts
  menuOptions: MenuOption[] = createMenuOptions(routes);
```

El haber añadido en las rutas la propiedad title, para luego leerla directamente en el componente,
hace que Jasmine detecte en el test las líneas de llamada a los componentes como no cubiertas

Por tanto añadimos un test para el fichero routes, que incluirá un componente de prueba

```ts
  @Component({
    template: '',
  })
  class TestComponent {
    private router = inject(Router);
    goto(route: string) {
      this.router.navigate([route]);
    }
  }
```

En el test

- espiaremos al método navigate del router
- llamaremos al método goto del componente
- comprobaremos que el método navigate ha sido llamado con el argumento esperado

```ts
  TestBed.configureTestingModule({
      imports: [RouterTestingModule.withRoutes(routes)],
    }).compileComponents();
    ...
    router = TestBed.inject(Router);
    navigateSpy = spyOn(router, 'navigate').and.callThrough();

    component.goto('home');
    expect(navigateSpy).toHaveBeenCalledWith(['home']);

    component.goto('about');
    expect(navigateSpy).toHaveBeenCalledWith(['about']);
```

#### Componente Contador (Counter): estado y eventos

Creamos un componente contador y lo añadimos en la página home

```shell
  ng g c components/counter
```

- Cualquier propiedad de la clase es en si un estado: sus cambios se reflejan en la vista
- En la vista podemos definir la respuesta a los eventos con el operador ()
- En esa respuesta podemos hacer directamente cambios en el estado, que automáticamente actualizaran la vista

```html
  <button type="button" (click)="counter =  counter - 1">➖</button>
  <span>{{counter}}</span>
  <button type="button" (click)="counter =  counter + 1">➕</button>
```

Sería mucho mejor práctica llevar la lógica a un método manejador del evento click

```ts
  updateCounter(value: number) {
    this.counter = this.counter + value;
  }
```

#### Uso condicional de clases CSS

La directiva ngClass es un ejemplo de las directivas de atributo
Para usar las directivas en un componente es necesario importar en él CommonModule

NgClass se puede usar de varias maneras.
La más potente es vincularla con un objeto con la directiva en el que

- los nombres de las propiedades corresponden a clases CSS
- su valor boolean determina si se aplican o no

```html
  <span [ngClass]="{'negative': counter < 0}">{{counter}}</span>
```

#### Limites en el contador: renderizado condicional

Si definimos como límites -10 y 10, podemos deshabilitar el botón que ya no es valido dando al atributo disable un valor booleano.
Vemos de nuevo como el operador [] permite vincular un atributo a una expresión

```html
  <button type="button" (click)="updateCounter(-1)" [disabled]="counter === -10">➖</button>
  <span [ngClass]="{negative: counter < 0}">{{counter}}</span>
  <button type="button" (click)="updateCounter(+1)" [disabled]="counter === 10">➕</button>
```

Pero ademas, podemos añadir información al usuario que se renderizará condicionalmente
Para ello tenemos también un nuevo flow control, @if, que viene a sustituir a la directiva estructural nf-if

```html
  @if (counter === 10) {
  <p class="info">has alcanzado el límite superior</p>
  } @else if (counter === -10) {
  <p class="info">has alcanzado el límite inferior</p>
```

#### Componente saludo: two-way data binding with ngModel

Creamos un componente saludo y lo añadimos en la página home

```shell
  ng g c components/greeting
```

Añadimos un input de HTML y vemos como vincularlo a una propiedad,
de forma similar a lo que hacemos en los formularios controlados de react

```html
 <input type="text" placeholder="Dime tu nombre" [value]="user" (input)="updateInput($event)">
```

```ts
 updateInput(event: Event) {
    this.user = (event.target! as HTMLInputElement).value as string;
  }
```

El value del input se iguala a la propiedad del componente
En respuesta al evento input, se actualiza la propiedad con el valor del input

Podemos añadir un botón de borrado, que elimina el valor de la propiedad
reflejándose en el template, incluso en el valor del input

```ts
  cleanInputUser() {
    this.user = '';
  }
```

De esta forma se consigue el binding bidireccional (two-way data binding)
entre la vista (template) y el componente

Además, Angular proporciona una directiva de atributo, **ngModel**,
junto con su evento específico **ngModelChange** que permiten reescribir el código de forma mas simple

Para usarla debemos importar formsModule en nuestro componente

```html
  <input type="text" placeholder="El nombre de tu mascota" [ngModel]="pet" (ngModelChange)="pet = $event">
```

Finalmente, la referencia a la directiva y su método puede unificarse con el operador [()] con ngModel.
Así es como usaremos siempre el binding bidireccional

```html
<input type="text" placeholder="Y de donde eres" [(ngModel)]="place">
```

#### Los estilos y los componentes

El fichero de estilos src/styles define los estilos generales.

En el podemos colocar las variables que teníamos en el componente sample o las propiedades de main

La etiqueta main la pasamos a app.component, quitándola de sample, ya que solo puede ser usada una vez.

Como vemos, el css se sigue aplicando, ya que esta en el fichero global, no vinculado a ningún componente.

En el componente sample sigue existiendo la etiqueta **:host**, auto-referencia al propio componente

```scss
:host {
  min-height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 1rem;
  position: relative;
}
```

Para comprobar la encapsulación de los estilos, vamos al componente counter y
aplicamos el estilo al párrafo de mensaje directamente en la etiqueta p, sin usar clases

Los párrafos de otros componente no se ven afectados

Creamos un componente mensaje para incluirlo en counter y ver que pasa con el css en un componente hijo

```shell
  ng g c components/message
```

Tampoco le afecta el css del componente: los estilos están encapsulados en su componente

Podemos ver en el inspector de las developer Tools como se consigue esto aplicando los estilos
junto con atributos en forma de hash creados por Angular durante la compilación

Este comportamiento puede modificarse con el metadato **encapsulation** al que podemos asignar el valor **ViewEncapsulation.None**

### Challenge 1

Crea una página **works** con su correspondiente ruta y acceso desde el menú
Crea en ella un componente **estilos** que

- recoja un texto en un input, con un botón que permita borrarlo
- recoja los valores de color, tamaño y tipo de fuente
- muestre el texto aplicándole todos los valores recogidos

Testa a fondo el componente

Pista: usa la directiva de atributo ngStyle, similar a ngClass pero para aplicar estilos inline, sin usar clases
Ya sabes que esto no es en general una buena práctica, pero es necesario en este caso

#### Solución de Challenge 1

Añadimos la página, la ruta y la opción en el array con las opciones de componente menu

```shell
ng g c pages/work -t -s --project demo
```

Creamos el componente styles y lo incorporamos a la página

```shell
ng g c components/styles --project demo
```

La entrada del texto, su display y el botón de borrar reflejan el two-wat data binding que ya conocemos

Añadimos los inputs de color y tamaño y un select para la lista de fuentes.
Es fácil encontrar como conseguir la lista con una pequeña función  (no es importante)

Para crear un select/options iteramos sobre el array con @for

```html
  <select [(ngModel)]="font">
    <option value=""></option>
    @for (item of availableFonts; track $index) {
    <option [value]="item">{{item}}</option>
    }
  </select>
```

La presentación del texto en pantalla recibe los estilos elegidos por el usuario de forma dinámica gracias a propiedades de [style] asociadas a variables

```html
  <output [style.color]="refColor.value ? refColor.value : '#000000' " [style.fontSize]="size + 'rem'"
      [style.fontFamily]="font ? font : 'inherit'">{{sample}}</output>
```

Las variables están asociadas a los inputs de color y tamaño y al select de fuentes a traves de ngModel con propiedades del componente o utilizando referencias locales de la vista, independientes de la lógica del componente.

```html
  <input type="color" name="" id="" ngModel #color> // referencia local
  <input type="number" step="0.5" min="0.5" max="5" [(ngModel)]="size"> // propiedad del componente
```

Estas variables pueden incluso ser leídas en el componente gracias al decorador @ViewChild

```ts

export class StylesComponent implements OnInit {
  ...
  @ViewChild('refColor', { static: true }) color!: ElementRef;

  ngOnInit(): void {
    this.getFonts();
    console.log('Color:', this.color.nativeElement.value);
  }
  ... }
```

En cuanto a los test:

- comprobamos que se puede dar valor al input, que se refleja el texto y que se puede borrar
- comprobamos que se pueden asignar valores a los controles de los estilos y que estos aparecen en la vista, tal como hemos programado

El único caso novedoso es el select, que a diferencia del input, tiene asociado el evento change

```ts
  it('should use the style values selected', () => {
    component.availableFonts = new Set(['Arial']);
    fixture.detectChanges();
     const selectElement: HTMLSelectElement = debugElement.query(
      By.css('.styles select')
    ).nativeElement;
    const pElement: HTMLParagraphElement = debugElement.query(
      By.css('p')
    ).nativeElement;
    selectElement.value = selectElement.options[1].value;
    // También válido
    // selectElement.value = 'Arial';
    selectElement.dispatchEvent(new Event('change'));
    fixture.detectChanges();
    expect(pElement.textContent).toContain('Arial');
  });
```

### Librerías, más componentes. Proyección de componentes

Los workspaces, además de aplicaciones pueden contener librerías:

- no tiene index.html, porque no se renderizan directamente
- exportan elementos (componentes, servicios...) pare ser usados en las aplicaciones
- pueden ser publicadas en npm de forma pública o privada

#### Creación de una librería

Creamos la librería 'core'

```shell
ng g lib core -p isdi --dry-run
```

El resultado es

```shell
CREATE projects/core/ng-package.json (159 bytes)
CREATE projects/core/package.json (220 bytes)
CREATE projects/core/README.md (987 bytes)
CREATE projects/core/tsconfig.lib.json (328 bytes)
CREATE projects/core/tsconfig.lib.prod.json (250 bytes)
CREATE projects/core/tsconfig.spec.json (287 bytes)
CREATE projects/core/src/public-api.ts (118 bytes)
CREATE projects/core/src/lib/core.component.spec.ts (605 bytes)
CREATE projects/core/src/lib/core.component.ts (235 bytes)
CREATE projects/core/src/lib/core.service.spec.ts (363 bytes)
CREATE projects/core/src/lib/core.service.ts (142 bytes)
CREATE projects/core/.eslintrc.json (647 bytes)
UPDATE angular.json (4503 bytes)
UPDATE package.json (1611 bytes)
UPDATE tsconfig.json (971 bytes)
```

El scaffolding es más simple que el de una aplicación

Ficheros de configuración de TS

- projects/core/tsconfig.lib.json (328 bytes)
- projects/core/tsconfig.lib.prod.json (250 bytes)
- projects/core/tsconfig.spec.json (287 bytes)

Readme, .eslintrc.json, package.json y configuración propia de Angular

- projects/core/README.md (987 bytes)
- projects/core/.eslintrc.json (647 bytes)
- projects/core/package.json (220 bytes)
- projects/core/ng-package.json (159 bytes)

En la carpeta sources (src)

Ejemplos de componente y servicio

- projects/core/src/lib/core.component.spec.ts (605 bytes)
- projects/core/src/lib/core.component.ts (235 bytes)
- projects/core/src/lib/core.service.spec.ts (363 bytes)
- projects/core/src/lib/core.service.ts (142 bytes)

Definición del API de la librería, con los elementos que exporta

- projects/core/src/public-api.ts (118 bytes)

En el workspace se actualizan los ficheros

UPDATE angular.json (4503 bytes)
UPDATE package.json (1611 bytes)
UPDATE tsconfig.json (971 bytes)

El cambio en tsconfig.json supone añadir un path que mapea la nueva librería,
necesario para poder usarla desde las aplicaciones del workspace sin instalarla
siempre que la tengamos compilada (build) para que este disponible en la carpeta dist/core

Para ello es util añadir una variación al script watch de npm

```json
  "build:lib": "ng build --watch --configuration development --project core",
```

La primera vez puede dar un error Cannot find module 'ng-packagr'
que se corrige con un npm i para actualizar el paquete que no ha sido instalado correctamente

```shell
Building Angular Package

------------------------------------------------------------------------------
Building entry point 'core'
------------------------------------------------------------------------------
✔ Compiling with Angular sources in Ivy full compilation mode.
✔ Generating FESM bundles
✔ Copying assets
✔ Writing package manifest
✔ Built core

------------------------------------------------------------------------------
Built Angular Package
 - from: D:\Desarrollo\Skylab.base\trying\ng.17.taller\projects\core
 - to:   D:\Desarrollo\Skylab.base\trying\ng.17.taller\dist\core
------------------------------------------------------------------------------
```

Comprobamos que podemos importar el componente CoreComponent
desde la aplicación como desde cualquier librería instalada

```ts
import { CoreComponent} from 'core';

@Component({
  ...
  imports: [CommonModule, RouterOutlet, MenuComponent, CoreComponent],
  ...
  })
```

Una vez importado, lo consumimos por su selector, como cualquier componente

#### Componentes Header y Footer en la librería

Añadimos los clásicos componentes header y footer en la librería.
Como en otros componentes podríamos optar por hacer inline template (-t) y estilos (-s)
o por prescindir de la carpeta para el componente (--flat)

```shell
  ng g c components/header --project core -t -s --flat --dry-run
```

En nuestro caso, los dejamos con el estilo que venimos usando en la aplicación

```shell
  ng g c components/header --project core
  ng g c components/footer --project core
```

Para poder usar los nuevos componentes los añadimos al API de la librería (public-api.ts)

En los estilos de los componentes de la librería podemos hacer referencia a variables CSS que definiremos en la aplicación.

#### Componente Layout: proyección de componentes

En lugar de exportar header y footer podemos crear un componente layout

```shell
  ng g c components/layout --project core
```

En el consumiremos header y footer dejando un espacio para todo el contenido que envuelva el componente

Para indicar donde se colocará el contenido utilizamos la directiva ngContent

```html
<isdi-header></isdi-header>

<ng-content></ng-content>

<isdi-footer></isdi-footer>
```

Para poder usar el nuevo componentes lo añadimos al API de la librería (public-api.ts).
Al mismo tiempo dejamos de exportar header y footer

Al consumir el componente en la aplicación es un wrapper que envuelve todo el contenido que se va a proyectar dentro de el

```html
<isdi-layout>
  <isdi-menu></isdi-menu>
  <main class="main">
    <router-outlet></router-outlet>
  </main>
</isdi-layout>
```

#### Componente Logo

Incorporamos en la librería un componente logo que ya nos dan hecho

Lo usamos el header, pasándole los parámetros que necesita.
Como veremos a partir de aquí, los componentes se comunican entre si

#### Proyección de más de un contenido

Si queremos integrar el menu en el header a nivel de html, el layout deberá
recibir dos contenidos diferentes y colocarlos donde corresponda

Angular lo permite en base a cualquier selector válido de los contenidos

```html
<isdi-header>
  <ng-content select='.menu'></ng-content>
</isdi-header>

<ng-content select=".main"></ng-content>

<isdi-footer></isdi-footer>
```

A su vez el menu se proyecta al componente header, que tendrá definido donde renderizarlo

Una vez definido así, usamos el layout en la aplicación como wrapper de los dos elementos que espera recibir

```html
<isdi-layout>
  <isdi-menu class="menu"></isdi-menu>
  <main class="main">
    <router-outlet></router-outlet>
  </main>
</isdi-layout>
```

Como se ve la proyección de contenido es una potente herramienta que permite la **composición de componentes**, muy utilizada por las librerías al permitir componentes envolventes preparados para manejar y renderizar el contenido que les será proporcionado en las aplicaciones

### Pipes

Son funciones transformadoras de la salida de datos que se utilizan de forma declarativa, en los templates

Existen una serie de Built-in pipes

- DatePipe: Formats a date value according to locale rules.
- UpperCasePipe: Transforms text to all upper case.
- LowerCasePipe: Transforms text to all lower case.
- CurrencyPipe: Transforms a number to a currency string, formatted according to locale rules.
- DecimalPipe: Transforms a number into a string with a decimal point, formatted according to locale rules.
- PercentPipe: Transforms a number to a percentage string, formatted according to locale rules.
- AsyncPipe: Subscribe and unsubscribe to an asynchronous source such as an observable.
- JsonPipe: Display a component object property to the screen as JSON for debugging.

Para ver el uso de DatePipe, añadimos la fecha y hora en el **componente Mensaje**, que tendrá que importar DatePipe

Este sería el aspecto inicial:

```ui
Pagina cargada Thu Jan 11 2024 14:04:40 GMT+0100 (hora estándar de Europa central)
```

Y este cuando filtramos la salida para darle un formato

```ui
Pagina cargada  Thursday, January 11, 2024
```

#### Valores "localizados": Locale

Los pipes con Date, Currency, Decimal y Percent pueden recibir un parámetro que les indica la localización a usar,
que debe haber sido previamente registrada en el fichero de configuración (app.config.ts)

```ts
import localeEs from '@angular/common/locales/es';
import { registerLocaleData } from '@angular/common';

registerLocaleData(localeEs);
```

A partir de ahí, podemos indicas la localización ES en los formatos de los pipes citados

```html
<p>Pagina cargada el {{today | date: 'fullDate' : '' : 'ES' }}
  a las {{today | date: 'mediumTime' : '' : 'ES' }}
</p>
```

Otra posibilidad es cambiar globalmente el locale que usa la aplicación, en el mismo app.config.ts

Importando el token LOCALE_ID y añadiéndolo al provider global de la aplicación con un valor 'es'

```ts
import { ApplicationConfig, LOCALE_ID } from '@angular/core';
...

export const appConfig: ApplicationConfig = {
  providers: [{ provide: LOCALE_ID, useValue: 'es' }, provideRouter(routes)],
};

```

### _Testing de los componentes_

#### _Test de la aplicación_

Los errores de los test iniciales suelen deberse a las carencias del entorno de test, frente al entorno de ejecución del componente.

El error NullInjectorError indica que en el test no hay un provider del servicio, es decir no se esta importando algún modulo.
En el caso del RouterModule, lo sustituimos por el RouterTestingModule que se importa de'@angular/router/testing'.

Sin apenas más cambios este es nuestro resultado

```shell
√ 10 tests completed
-------------------------|---------|----------|---------|---------|-------------------
File                     | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
-------------------------|---------|----------|---------|---------|-------------------
All files                |   89.28 |      100 |      70 |      85 |
 app                     |     100 |      100 |     100 |     100 |
  app.component.ts       |     100 |      100 |     100 |     100 |
 app/components/counter  |      75 |      100 |      50 |   66.66 |
  counter.component.ts   |      75 |      100 |      50 |   66.66 | 17
 app/components/greeting |   71.42 |      100 |   33.33 |   66.66 |
  greeting.component.ts  |   71.42 |      100 |   33.33 |   66.66 | 17-21
 app/components/menu     |     100 |      100 |     100 |     100 |
  menu.component.ts      |     100 |      100 |     100 |     100 |
 app/components/message  |     100 |      100 |     100 |     100 |
  message.component.ts   |     100 |      100 |     100 |     100 |
 app/components/sample   |     100 |      100 |     100 |     100 |
  sample.component.ts    |     100 |      100 |     100 |     100 |
 app/pages/about         |     100 |      100 |     100 |     100 |
  about.component.ts     |     100 |      100 |     100 |     100 |
 app/pages/home          |     100 |      100 |     100 |     100 |
  home.component.ts      |     100 |      100 |     100 |     100 |
-------------------------|---------|----------|---------|---------|-------------------
```

Hay que tener en cuenta que son solo los test de humo que auto-completa Angular y que,
con independencia del coverage, solo están testando que se instancian correctamente los componentes.

#### _Tests de la librería_

En el caso de la librería, falta ajustar la configuración como hicimos en la aplicación.

```shell
ng g config karma --project core
```

Crea el fichero de configuración y lo referencia en angular.json

```shell
CREATE projects/core/karma.conf.js (1356 bytes)
UPDATE angular.json (4561 bytes)
```

Aplicamos la misma configuración de karma que a la aplicación en projects/core/karma.conf.js

```js
  plugins: [
      // ...
      require("karma-mocha-reporter"),
      require("@angular-devkit/build-angular/plugins/karma"),
    ],


    coverageReporter: {
      //...
      reporters: [{ type: "lcov" }, { type: "text" }],
    },
    reporters: ["mocha", "kjhtml"],
    //...

```

Los resultados de partida parecen aún más contundentes

```shell
√ 7 tests completed
-----------------------|---------|----------|---------|---------|-------------------
File                   | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s
-----------------------|---------|----------|---------|---------|-------------------
All files              |     100 |      100 |     100 |     100 |
 lib                   |     100 |      100 |     100 |     100 |
  core.component.ts    |     100 |      100 |     100 |     100 |
  core.service.ts      |     100 |      100 |     100 |     100 |
 lib/components/footer |     100 |      100 |     100 |     100 |
  footer.component.ts  |     100 |      100 |     100 |     100 |
 lib/components/header |     100 |      100 |     100 |     100 |
  header.component.ts  |     100 |      100 |     100 |     100 |
 lib/components/layout |     100 |      100 |     100 |     100 |
  layout.component.ts  |     100 |      100 |     100 |     100 |
 lib/components/logo   |     100 |      100 |     100 |     100 |
  logo.component.ts    |     100 |      100 |     100 |     100 |
-----------------------|---------|----------|---------|---------|-------------------
```

#### _Test del componente Message_

Aunque ya tiene un 100% de coverage, deberíamos testar ue renderiza realmente lo esperado.

- Añadimos el debugElement a partir de la fixture
- Buscamos él con el selector de la etiqueta p
- Nos quedamos con el correspondiente nativeElement
- Comprobamos que contiene el texto esperado

```ts
  it('should render a paragraph', () => {
    let pElement: HTMLParagraphElement = debugElement.query(
      By.css('p')
    ).nativeElement;
    expect(pElement.textContent).toContain('Página cargada');
  });
```

#### _Test del componente Menu_

A diferencia de lo que sucede en Jest, tenemos acceso a las propiedades de la instancia.
Por ejemplo podríamos añadir una nueva opción al menu y comprobar que se renderiza

```ts
  it('should render a menu item', () => {
    component.options.push({
      path: 'Test',
      label: 'Test',
    });
    fixture.detectChanges();
    let itemElement: HTMLLiElement = debugElement.queryAll(By.css('li'))[2]
      .nativeElement;
    expect(itemElement.textContent).toContain('Test');
  });
```

#### _Test del componente Counter_

Como tenemos botones, debemos comprobar su funcionalidad.

El debugElement dispone para es del método triggerEventHandler() para disparar el click del botón.
Después de usarlo es importante lanzar **fixture.detectChanges()** para que la vista refleje los cambios en el componente. El proceso de detección del cambio automático en los componentes de Angular no lo es en el entorno de test, por lo que hay que ejecutar el correspondiente método de la fixture

```ts
 describe('When we use the buttons', () => {
    let spanElement: HTMLSpanElement;
    let buttonDebugElements: DebugElement[];
    beforeEach(() => {
      spanElement = debugElement.query(By.css('span')).nativeElement;
      buttonDebugElements = debugElement.queryAll(By.css('button'));
    });

    it('should increase the display when the button + is clicked', () => {
      component.counter = 0;
      buttonDebugElements[1].triggerEventHandler('click');
      fixture.detectChanges();
      expect(spanElement.textContent).toBe('1');
    });

    it('should increase the display when the button + is clicked', () => {
      component.counter = 0;
      buttonDebugElements[0].triggerEventHandler('click');
      fixture.detectChanges();
      expect(spanElement.textContent).toBe('-1');
    });
  });
```

#### _Test del componente Greeting_

Las responsabilidades de este componente son

- recoger el valor que escribe el usuario
- actualizar con el el estado del componente y reflejarlo en la vista
- responder al click en el botón modificando el estado y la vista

Para tester lo primero, accedemos al input, cambiamos su valor y despachamos un evento input.
De esa forma simulamos la interacción del usuario con el input
A continuación, tras lanzar la detección de cambios, comprobamos que la vista se ha actualizado.

Como ya vimos antes, disparamos el evento click del botón con el método triggerEventHandler del debugElement
y de nuevo, tras lanzar la detección de cambios, comprobamos que la vista se ha actualizado.

```ts
  it('should type a user name and see in the document', () => {
    let inputElement: HTMLInputElement = debugElement.query(
      By.css('.user input')
    ).nativeElement;
    inputElement.value = 'Test';
    inputElement.dispatchEvent(new Event('input'));
    fixture.detectChanges();

    let pElement: HTMLParagraphElement = debugElement.query(
      By.css('.user p')
    ).nativeElement;
    expect(pElement.textContent).toBe('Hola Test');

    let buttonDebugElement = debugElement.query(By.css('.user button'));
    buttonDebugElement.triggerEventHandler('click');
    fixture.detectChanges();
    expect(pElement.textContent).toBe('Hola amigo');
  });
```

### Challenge 2. Construyendo componentes

#### Redistribuyendo un componente

- A partir del componente Sample (el ejemplo de Angular) creamos 3 nuevos componentes

  - el logotipo de Angular
  - la lista de enlaces
  - la lista de redes sociales

Repasa el uso de Built-in control flow @for (antes directivas estructurales)
Comprueba como se crean componentes para encapsular SVG

##### Solución: Componentización del ejemplo que viene con Angular

Añadimos 3 nuevos componentes

```shell
ng g c components/sample/links -t -s --project demo
ng g c components/sample/socials -t -s --project demo
ng g c components/sample/angular-logo -t -s --project demo
```

Redistribuimos los elementos del componente inicial

- el logotipo de Angular: el componente se limita a encapsular el svg para poder utilizarlo donde sea necesario
- la lista de enlaces, que los guarda como un array para iterar sobre ellos
- la lista de redes sociales, que de nuevo se guardan como un array para iterar sobre ellos

#### Página TODO. Componente 'TODO List' unitario

Crea una lista de tareas en un solo componente
Las tareas estarán en un array en el propio componente
Se ajustaran a un modelo o entidad:  id - titulo - isComplete
El id sera generado con crypto
Se podrá cambiar el estado de la tarea de completa a incompleta
Se podrá cambiar el titulo en la propia lista

Repasa el uso de

- Built-in control flow (antes directivas estructurales):  @for / @if
- directivas de atributo y CSS: ngClass (y ngStyle)
- two-way data binding
- manejadores de eventos: (click) ...

##### Solución del Challenge 2: ToDo List

Generamos el  modelo de datos (entidad)

```shell
ng g i entities/task --project demo
```

Creamos el componente ToDo y lo consumimos en la página works

```shell
  ng g c components/todo --project demo
```

El componente importara FormsModules, para poder vincular el input de nueva tarea con ngModel

##### La vista (template)

En la vista (template) incluimos

- un **details** para la parte del componente que añade tareas. s
  - un input, con la estética que ya hemos utilizado, ligado con un ngModel
  - un botón con su manejador del evento click
  - un párrafo de errores, que se renderiza condicionalmente cuando hays errores

Como solo hay un input y no hemos visto aún formularios, no lo utilizamos

```html
  <details #refDetails>
    <summary>Añadir tarea</summary>
    <div class="form">
      <div class="control">
        <label>
          <!-- Don`t remove placeholder: used by CSS implementation -->
          <input type="text" placeholder=" " [(ngModel)]="title" (focus)="addError = ''">
          <span>Describe la tarea</span>
        </label>
      </div>
      <div class="buttons">
        <button type="button" (click)="handleAddTask()">Add</button>
      </div>
    </div>
    @if (addError) {<p class="info-error">{{addError}}</p>}

  </details>
```

- una **lista** que itera sobre el array de tareas
- cada **item** de la lista tendrá
  - un checkbox con el atributo checked ligado al item.isComplete
  - un input ligado con ngModel al item.title, que
    - sera readonly hasta que pasemos a modo edición con el botón correspondiente
    - tendrá un manejador del evento blur para salvar cuando dejemos de editar
  - dos botones para editar y borrar con sus manejadores del eventoClick

```html
  <ul #refLista>
    @for (item of tasks; track item.id) {
      <li [title]="item.id" [id]="item.id">
        <div class="card">
          <span><input type="checkbox" [checked]="item.isComplete" (change)="handleChangeTasks(item)"></span>
          <input type="text" [readOnly]="!editMode[item.id]" [(ngModel)]="item.title" (blur)="handleSave(item)" />

          <!-- <span [contentEditable]="editMode">{{item.title}}</span> -->

          <span class="buttons">
            @if (!editMode[item.id]) {
            <button type="button" (click)="handleEdit(item)">Edit</button>

            }
            <button type="button" (click)="handleDeleteTask(item)">Delete</button>
          </span>
        </div>

      </li>
    }
  </ul>
```

Tanto en el details como en la lista (ul) incorporamos referencias locales que permitirán desde el componente acceder a los elementos del DOM, para operaciones como colapsar el details o darle foco al input al activar su edición

##### La lógica del componente

Para obtener unos datos iniciales, creamos un fichero tasks mock, donde una función nos devuelve una promesa con un array de tareas predefinido (hardcoded) en el propio fichero.

En el ngOnInit del componente cargamos los datos, como si vinieran de un API.

Los manejadores de eventos responden a cada uno de los eventos asociados a ellos en la vista

- handleAddTask: añadir tareas
- handleChangeTasks: cambiar el estado 'completada' de una tarea
- handleEdit: poner en modo edición el titulo de una tarea
- handleSave: salir del modo edición salvando los datos
- handleDeleteTask: borrar una tarea

```ts
  handleAddTask() {
    if (!this.title) {
      this.addError = 'Invalid data';
      return;
    }
    const newTaskData: Omit<Task, 'id' | 'isComplete'> = {
      title: this.title,
    };
    this.title = '';
    this.addTask(newTaskData);
    this.refDetails.nativeElement.removeAttribute('open');
  }

  handleChangeTasks(item: Task) {
    item.isComplete = !item.isComplete;
    this.updateTask(item);
  }

  handleEdit(item: Task) {
    this.editMode[item.id] = true;
    this.refLista.nativeElement.children[
      item.id
    ].children[0].children[1].focus();
  }

  handleSave(item: Task) {
    this.editMode[item.id] = false;
    this.updateTask(item);
  }

  handleDeleteTask(item: Task) {
    this.deleteTask(item);
    delete this.editMode[item.id];
  }
```

Como previo a llevar parte de la lógica a un servicio aplicando el patrón repo,
las operaciones sobre el array se han llevado a métodos separados, invocados desde los manejadores:

- addTask
- updateTask
- deleteTask

```ts
  addTask(taskData: Omit<Task, 'id' | 'isComplete'>) {
    const task: Task = {
      id: crypto.randomUUID(),
      isComplete: false,
      ...taskData,
    };
    this.tasks = [...this.tasks, task];
  }

  updateTask(updatedItem: Task) {
    this.tasks = this.tasks.map((item) =>
      item.id === updatedItem.id ? updatedItem : item
    );
  }

  deleteTask(deletedItem: Task) {
    this.tasks = this.tasks.filter((item) => item.id !== deletedItem.id);
  }
```

##### _Los tests_

En este caso, como nuestro componente tiene mucha lógica, y esta no se ve cubierta por el test base, tenemos apenas un 30% de coverage de partida

En los test tendremos que cubrir las responsabilidades del componente:

- añadir una tares
- pasar a completa/incompleta una tarea
- modificar el texto de una tarea
- eliminar una tarea

Como las tareas iniciales ya son en cierto modo un mock, podemos dejarlas en el test.

En el beforeAll inicial, tenemos que esperar de ngOnInit termine el proceso de carga asíncrona de los datos

```ts
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [TodoComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(TodoComponent);
    component = fixture.componentInstance;
    debugElement = fixture.debugElement;
    fixture.detectChanges(); // dispara ngOnInit
    await fixture.whenStable();
    fixture.detectChanges();
  });
```

El resto de los test escribe en los inputs, hace check o click y emitir los eventos correspondientes (input, change, blur) a los que hay asociados manejadores, de forma muy similar a lo que ya hemos visto

### Scripts npm y Terminales

Al tener varios proyectos (aplicaciones, librerías) con sus terminales para ejecutar

- el build de desarrollo (npm start -- --project ...)
- los test (npm test -- --project ...)

puede ser util ir creando nuevos scrips en npm

Otra opción es guardar los terminales con los comandos que ejecutan,
gracias a la extensión de VSC **Restore Terminals**

Las configuraciones de esta extensión se almacenan en los settings del workspace
(.vscode/setting.json)

